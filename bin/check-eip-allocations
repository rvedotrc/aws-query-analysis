#!/usr/bin/env ruby

require 'json'

def accounts
  Dir.entries("aws-query/account-id").reject {|n| n.start_with? "."}.sort
end

def regions(account_id, service = "ec2")
  Dir.entries("aws-query/account-id/#{account_id}/service/#{service}/region").reject {|n| n.start_with? "."}.sort
end

class EipChecker

  attr_reader :account_id, :region

  def initialize(account_id, region)
    @account_id = account_id
    @region = region
  end

  def eips_created_by_stacks
    files = Dir.glob("cloudformation-mirror/account-id/#{account_id}/service/cloudformation/region/#{region}/stack/*/resources.json")

    files.each_with_object({}) do |f, h|
      stack_name = f.split('/')[8]
      JSON.parse(IO.read f)["StackResourceSummaries"].each do |res|
        if res["ResourceType"] == "AWS::EC2::EIP"
          ip = res["PhysicalResourceId"]
          raise "Already seen IP #{ip}" if h.has_key? ip
          h[ip] = res.merge "StackName" => stack_name
        end
      end
    end
  end

  def parse_eip_allocations(list, name)
    # Let's assume that value is a space/comma -separated list of eip ids,
    # either of the form "eip-xxxxx" or "xxxxx" (without the "eipalloc-" prefix).
    ids = (list || "").split(/[ ,]+/)

    ids.each do |id|
      bad = id.match(/^(eipalloc-)?([0-9a-f]{8})$/).nil?
      if bad
        raise "EIP id #{eip_id} in #{name} looks malformed"
      end
    end

    ids.each do |eip_id|
      eip_id.gsub! /^(?!eipalloc-)/, "eipalloc-"
    end

    ids.sort.uniq
  end

  def eips_claimed_by_asgs
    file = "aws-query/account-id/#{account_id}/service/autoscaling/region/#{region}/describe-autoscaling-groups.json"

    JSON.parse(IO.read file)["AutoScalingGroups"].each_with_object({}) do |asg, h|
      name = asg["AutoScalingGroupName"]
      min = asg["MinSize"]
      max = asg["MaxSize"]

      tags = (asg["Tags"] || []).each_with_object({}) do |t, h|
        h[t["Key"]] = t["Value"]
      end

      asg_data = { asg: name, max: max }
      asg_data[:stack] = tags["aws:cloudformation:stack-name"] if tags.has_key? "aws:cloudformation:stack-name"
      asg_data[:logical_name] = tags["aws:cloudformation:logical-id"] if tags.has_key? "aws:cloudformation:logical-id"

      # The "EipAllocations" tag, and IPs being "claimed" by ASGs, is BBC-specific
      ids = parse_eip_allocations(tags["EipAllocations"], name)

      # If there are no allocations at all, assume this ASG doesn't use EIPs
      next if ids.empty?

      puts JSON.generate(account_id: account_id, region: region, level: "debug", asg: name, max: max, eips: ids)

      if max > ids.count
        puts JSON.generate(account_id: account_id, region: region, level: "warning", asg_too_big: name, max: max, allocations: ids.count)
      elsif max < ids.count
        puts JSON.generate(account_id: account_id, region: region, level: "warning", asg_too_small: name, max: max, allocations: ids.count)
      end

      ids.each do |eip_id|
        puts JSON.generate({ account_id: account_id, region: region, level: "debug", referenced_eip_id: eip_id })
        h[eip_id] ||= []
        h[eip_id] << asg_data
      end
    end
  end

  def run
    addrs_file = "aws-query/account-id/#{account_id}/service/ec2/region/#{region}/describe-addresses.json"

    addresses = JSON.parse(IO.read addrs_file)["Addresses"]
    return if addresses.empty?

    ip_to_stack = eips_created_by_stacks
    id_to_asgs = eips_claimed_by_asgs

    id_to_asgs.each do |eip_id, claimed_by|
      if claimed_by.count > 1
        puts JSON.generate({ account_id: account_id, region: region, level: "warning", message: "EIP is claimed by more than one ASG", id: eip_id, claimed_by: claimed_by })
      end

      # Does each ASG-configured EIP actually exist?
      ip = addresses.find {|i| i["AllocationId"] == eip_id}
      unless ip
        puts JSON.generate({ account_id: account_id, region: region, level: "error", invalid_ip: eip_id, claimed_by: claimed_by})
      end
    end

    addresses.each do |address|
      # p address.keys.sort
      # 31.97%          94 ["AllocationId", "Domain", "PublicIp"]
      #  2.38%           7 ["Domain", "InstanceId", "PublicIp"]
      # 65.65%         193 ["AllocationId", "AssociationId", "Domain", "InstanceId", "NetworkInterfaceId", "NetworkInterfaceOwnerId", "PrivateIpAddress", "PublicIp"]

      id = address["AllocationId"] # e.g. eipalloc-12345678
      ip = address["PublicIp"] # e.g. 1.2.3.4
      res = ip_to_stack[ip]

      h = {
        account_id: account_id,
        region: region, 
        id: id,
        ip: ip,
      }
      h.merge! stack_name: res["StackName"], logical_name: res["LogicalResourceId"] if res

      h.merge! claimed_by: id_to_asgs[id] if id_to_asgs.has_key? id

      puts JSON.generate(
        h.merge(
          level: "info",
          message: "IP allocation summary",
        )
      )

      # IPs which are unattached, AND not claimed by an ASG, should probably be
      # deleted
      claimed_by = id_to_asgs[ address["AllocationId"] ]
      if address["InstanceId"].nil? and claimed_by.nil?
        puts JSON.generate(
          h.merge(
            level: "warning",
            message: "Unattached and unclaimed EIP",
          )
        )
      end

    end
  end

end

accounts.each do |account_id|
  regions(account_id).each do |region|
    EipChecker.new(account_id, region).run
  end
end
